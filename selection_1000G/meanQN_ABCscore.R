#!/usr/bin/R

if(!(require(argparse) )) install.packages("argparse")
if(!(require(tidyverse) )) install.packages("tidyverse")
if(!(require(ggplot2)   )) install.packages("ggplot2")
if(!(require(rstatix)   )) install.packages("rstatix")
if(!(require(ggrepel)   )) install.packages("ggrepel")

library(argparse)
library(tidyverse)
library(ggplot2)
library(rstatix)
library(ggrepel)
library(preprocessCore)

###### FUNCTIONS #######

mergeActivitiesContacts <- function(fnames,
                                    activity_col='activity_base',
                                    contact_col='hic_contact',
                                    bin_totals=FALSE,
                                    min_hic=0,
                                    merge_nonexpr=FALSE,
                                    debug=FALSE) {

    samp_col <- 'CellType'
    acols <- c('chr','start','end','name',activity_col)
    ccols <- c('chr','start','end','name','TargetGene',contact_col)

    if (bin_totals) {
        acols <- c(acols, 'hic_enh_total')
    }

    i <- 0
    prev_sn <- 'no sample'
    for (fn in fnames) {

        if (debug & i>1) break

        f <- read_tsv(fn)
        fa <- f %>% dplyr::select(all_of(acols)) %>% distinct()
        fc <- f %>% dplyr::select(all_of(ccols))

        if (bin_totals) {
            fa <- fa %>%
                # replace 'fake NAs' (generated by sparse matrix represenation of
                # zero hic_contact for 2 specific bins) with real bin total
                # from where bin was part of non-zero hic_contact (if applicable)
                group_by(across(all_of(acols[-length(acols)]))) %>%
                arrange(hic_enh_total, .by_group=TRUE) %>%
                dplyr::slice(1) %>%
                ungroup() %>%
                # real NAs have not been replaced yet for hic bin totals
                mutate(across(hic_enh_total, ~replace_na(.x, 0)))
        }

        sn <- str_split(f[[samp_col]][1],pattern='\\.',simplify=TRUE)[1]
        print(paste(sn, 'processing...'))
        rm(f)

        preN <- nrow(fa)
        fa <- fa %>%
            dplyr::filter(.data[[activity_col]]>=min_hic)
        if (bin_totals) {
            fa <- fa %>%
                dplyr::filter(hic_enh_total>=min_hic)
        }
        postN <- nrow(fa)
        print(paste(preN - postN,'elements dropped with',activity_col,'<',min_hic))

        preN <- nrow(fc)
        fc <- fc %>%
            dplyr::filter(.data[[contact_col]]>=min_hic)
        postN <- nrow(fc)
        print(paste(preN - postN,'elements dropped with',contact_col,'<',min_hic))

        fa <- fa %>%
            dplyr::rename("{activity_col}.{sn}" := {{activity_col}})
        if (bin_totals) {
            fa <- fa %>%
                dplyr::rename("hic_enh_total.{sn}" := hic_enh_total)
        }
        fc <- fc %>%
            dplyr::rename("{contact_col}.{sn}" := {{contact_col}})

        if (merge_nonexpr) {

            if (sn==prev_sn) {
                print('Concatenating activities/contacts for non-expressed genes')
                cfa <- rbind(cfa, fa) %>% distinct()
                cfc <- rbind(cfc, fc) %>% distinct()
                if (i==0) {
                    sa <- cfa
                    sc <- cfc
                } else {
                    print('    Merging activities...')
                    sa <- merge(sa, cfa)
                    print('    Merging contacts...')
                    sc <- merge(sc, cfc)
                }
                i <- i + 1
            } else {
                cfa <- fa
                cfc <- fc
                prev_sn <- sn
            }

        } else {

            if (i==0) {
                sa <- fa
                sc <- fc
            } else {
                print('    Merging activities...')
                sa <- merge(sa, fa)
                print('    Merging contacts...')
                sc <- merge(sc, fc)
            }
            i <- i + 1

        }


    }

    return(list(sa, sc))

}

qnorm_df <- function(df, colprefix='activity_base') {

    mat <- df %>%
        dplyr::select(dplyr::starts_with(colprefix)) %>%
        as.matrix()

    # no keep.names arg in older versions of preprocessCore
    matnames <- colnames(mat)
    matqn <- normalize.quantiles(mat)
    colnames(matqn) <- matnames

    dfqn <- cbind(
        df %>% dplyr::select(-starts_with(colprefix)),
        matqn
    )

    return(dfqn)
}

qnorm_separate_promoters <- function(df, colprefix='activity_base', filt_zeros=NULL) {

    # filt_zeros: all = filter out elements that are zero in all samples post-QN
    #             any = filter out elements that are zero in any sample post-QN

    if (!('class' %in% colnames(df))) {

        if (!('name' %in% colnames(df))) {
            stop('No promoter column info found...')
        }

        df <- df %>% separate(name,c('class',NA),sep='\\|',remove=FALSE)

    }

    pdf <- df %>% dplyr::filter(class=='promoter')
    npdf <- df %>% dplyr::filter(class!='promoter')

    pdfqn <- qnorm_df(pdf, colprefix=colprefix)
    npdfqn <- qnorm_df(npdf, colprefix=colprefix)

    dfqn <- rbind(pdfqn, npdfqn)

    if (filt_zeros=='all') { # filter out elements that are zero in all samples
      dfqn <- dfqn %>%
          dplyr::filter(if_any(starts_with(colprefix), ~ . > 0))
    } else if (filt_zeros=='any') { # filter out elements that are zero in any sample
      dfqn <- dfqn %>%
          dplyr::filter(if_all(starts_with(colprefix), ~ . > 0))
    } else {
      print("Keeping all post-QN zeros!")
    }

    return(dfqn)

}

compute_score <- function(df,
                          activity_col='activity_base',
                          contact_col='hic_contact_pl_scaled_adj',
                          prefix='ABC') {

    if (prefix %in% c('ABC','powerlaw')) {

        df <- df %>%
            mutate("{prefix}.Score.Numerator" := .data[[activity_col]] * .data[[contact_col]]) %>%
            group_by(TargetGene) %>%
            mutate(nEnh.ABC = sum(!is.na(.data[[paste0(prefix,'.Score.Numerator')]])), # to check that this is equal across samples
                   "{prefix}.Score" := .data[[paste0(prefix,'.Score.Numerator')]] / sum(.data[[paste0(prefix,'.Score.Numerator')]], na.rm=TRUE)) %>%
            ungroup()

    } else if (prefix=='chip') {

        df <- df %>%
            mutate(chip_estimate = sqrt(hic_enh_total * hic_tss_total)) %>%
            group_by(TargetGene) %>%
            mutate(nEnh.chip = sum(!is.na(chip_estimate)), # to check that this is equal across samples
                   chip_estimate_sum = sum(chip_estimate, na.rm=TRUE),
                   chip_estimate_sum1 = chip_estimate / sum(chip_estimate, na.rm=TRUE),
                   chip_estimate_adj = chip_estimate_sum1 / max(chip_estimate_sum1, na.rm=TRUE),
                   "{prefix}.Score" := chip_estimate_adj / sum(chip_estimate_adj, na.rm=TRUE)) %>%
            ungroup()

    } else if (prefix=='hic') {

        df <- df %>%
            mutate("{prefix}.Score.Numerator" := hic_estimate_adj) %>%
            group_by(TargetGene) %>%
            mutate(nEnh.hic = sum(!is.na(hic_estimate_adj)), # to check that this is equal across samples
                   "{prefix}.Score" := .data[[paste0(prefix,'.Score.Numerator')]] / sum(.data[[paste0(prefix,'.Score.Numerator')]], na.rm=TRUE)) %>%
            ungroup()

    } else if (prefix=='atac') {

        df <- df %>%
            mutate("{prefix}.Score.Numerator" := activity_base) %>%
            group_by(TargetGene) %>%
            mutate(nEnh.atac = sum(!is.na(activity_base)), # to check that this is equal across samples
                   activity_base_sum = sum(activity_base, na.rm=TRUE),
                    "{prefix}.Score" := .data[[paste0(prefix,'.Score.Numerator')]] / sum(.data[[paste0(prefix,'.Score.Numerator')]], na.rm=TRUE)) %>%
            ungroup()

    } else if (prefix=='activity') {

        df <- df %>%
            # estimate activity as geometric mean of chip extimate and atac
            mutate(activity_estimate = sqrt(activity_base * chip_estimate)) %>%
            group_by(TargetGene) %>%
            mutate(nEnh.activity = sum(!is.na(activity_estimate)), # to check that this is equal across samples
                   activity_estimate_sum = sum(activity_estimate, na.rm=TRUE),
                   activity_estimate_sum1 = activity_estimate / sum(activity_estimate, na.rm=TRUE),
                   activity_estimate_adj = activity_estimate_sum1 / max(activity_estimate_sum1, na.rm=TRUE),
                    "{prefix}.Score" := activity_estimate_adj / sum(activity_estimate_adj, na.rm=TRUE)) %>%
            ungroup()

    } else {
      stop(paste0("Score prefix '",prefix,"' not supported."))
    }



    return(df)

}

normalize_hichip <- function(df, decomp_scores=FALSE) {

    df <- df %>%
        # keep duplicate hichip columns for colname compatibility
        mutate(hic_contact_pl_scaled = normalized_hic_contact) %>%
        group_by(TargetGene) %>%
        mutate(hic_contact_sum = sum(hic_contact_pl_scaled, na.rm=TRUE), # for bias check
               hic_contact_sum1 = hic_contact_pl_scaled / sum(hic_contact_pl_scaled, na.rm=TRUE),
               hic_contact_pl_scaled_adj = hic_contact_sum1 / max(hic_contact_sum1, na.rm=TRUE)) %>%
        ungroup()

    if (decomp_scores) {

      df <- df %>%
          mutate(hic_estimate = hic_contact_pl_scaled / chip_estimate) %>%
          group_by(TargetGene) %>%
          mutate(hic_enh_total_sum = sum(hic_enh_total, na.rm=TRUE),
                 hic_tss_total_sum = sum(hic_tss_total, na.rm=TRUE),
                 hic_estimate_sum = sum(hic_estimate, na.rm=TRUE),
                 hic_estimate_sum1 = hic_estimate / sum(hic_estimate, na.rm=TRUE),
                 hic_estimate_adj = hic_estimate_sum1 / max(hic_estimate_sum1, na.rm=TRUE)) %>%
          ungroup() %>%
          mutate(hic_estimate_adj_old = hic_contact_pl_scaled_adj / chip_estimate_adj)

    }

    return(df)

}

getmode <- function(v) {
   uniqv <- unique(v)
   uniqv[which.max(tabulate(match(v, uniqv)))]
}

makeQNpredictions <- function(fnames, adf, edf, cdf, outdir='.', decomp_scores=FALSE, filt_zeros=NULL) {

    # takes list of prediction files (`fnames`) made without Q-norm and
    # replaces unnormalized activities and contacts with Q-normed values
    # corresponding to each samples's file from `adf` (Q-normed activities)
    # and `cdf` (Q-normed contacts), then computes ABC scores using the
    # new Q-normed values and overwriting the old scores

    if (decomp_scores) library(plyranges)

    samp_col <- 'CellType'
    replace_cols <- c('activity_base',
                      'TargetGenePromoterActivityQuantile',
                      'hic_enh_total',
                      'hic_tss_total',
                      'normalized_hic_contact',
                      'hic_contact_pl_scaled',
                      'hic_contact_sum1',
                      'hic_contact_pl_scaled_adj',
                      'ABC.Score.Numerator',
                      'ABC.Score',
                      'powerlaw.Score.Numerator',
                      'powerlaw.Score')

    remove_cols <- c('pop','replicate')
    adf <- adf %>% dplyr::select(-any_of(remove_cols))
    cdf <- cdf %>% dplyr::select(-any_of(remove_cols))
    edf <- edf %>% dplyr::select(-any_of(remove_cols))

    i <- 0
    for (fn in fnames) {

        f <- read_tsv(fn) %>%
            dplyr::select(-all_of(replace_cols))
        sn <- str_split(f[[samp_col]][1],pattern='\\.',simplify=TRUE)[1]
        print(paste(sn, 'processing...'))

        # # activities
        # currcol <- c(paste0('activity_base.',sn))
        # currcola <- currcol[1]
        # if (decomp_scores) {
        #     currcol <- c(currcol, paste0('hic_enh_total.',sn))
        #     currcolb <- currcol[2]
        # }
        # curr_adf <- adf %>%
        #     dplyr::select(-starts_with(c('activity_base','hic_enh_total')),all_of(currcol)) %>%
        #     dplyr::rename(activity_base := {{currcola}})
        # if (decomp_scores) curr_adf <- curr_adf %>% dplyr::rename(hic_enh_total := {{currcolb}})
        # print('    Merging activities...')
        # f <- merge(f, curr_adf)

        # activities
        currcol <- paste0('activity_base.',sn)
        curr_adf <- adf %>%
            dplyr::select(-starts_with('activity_base'),all_of(c(currcol))) %>%
            dplyr::rename(activity_base := {{currcol}})
        print('    Merging activities...')
        af <- merge(f, curr_adf)
        print("    Computing atac.Score ...")
        af <- compute_score(af, prefix='atac')
        print("    Computing powerlaw.Score ...")
        af <- compute_score(af, contact_col='powerlaw_contact_reference', prefix='powerlaw')

        if (decomp_scores) {

            # chip estimate
            currcol <- paste0('hic_enh_total.',sn)
            curr_edf <- edf %>%
                dplyr::select(-starts_with('hic_enh_total'),all_of(c(currcol))) %>%
                dplyr::rename(hic_enh_total := {{currcol}})
            ef <- merge(f, curr_edf)

            column_order <- c(colnames(ef), 'hic_tss_total')

            # overlap hic_enh_totals with TargetGeneTSSs to get Qnormed
            # hic_tss_totals
            ef <- ef %>%
                dplyr::rename(enh_start = start,
                              enh_end = end,
                              seqnames = chr,
                              start = TargetGeneTSS) %>%
                mutate(end = start + 1) %>%
                as_granges()

            curr_edf <- curr_edf %>%
                dplyr::filter(class=='promoter') %>%
                dplyr::select(chr, start, end, hic_enh_total) %>%
                dplyr::rename(seqnames = chr,
                              hic_tss_total = hic_enh_total) %>%
                as_granges()

            ef <- join_overlap_left(ef, curr_edf) %>%
                as_tibble() %>%
                dplyr::select(-end) %>%
                dplyr::rename(TargetGeneTSS = start,
                              chr = seqnames,
                              start = enh_start,
                              end = enh_end) %>%
                dplyr::select(all_of(column_order))

            print("    Computing chip.Score ...")
            ef <- compute_score(ef, prefix='chip')

        }

        # contacts
        currcol <- paste0('hic_contact.',sn)
        curr_cdf <- cdf %>%
            dplyr::select(-starts_with('hic_contact'),all_of(c(currcol))) %>%
            dplyr::rename(normalized_hic_contact := {{currcol}})
        print('    Merging contacts...')
        # merge with pre-computed ChIP scores since non-zero contacts should be
        # a subset of these, but check this
        Npre <- nrow(ef)
        ef <- merge(ef, curr_cdf)
        Npost <- nrow(ef)
        zeros_print <- filt_zeros
        if (is.null(zeros_print)) zeros_print <- "no zeros filtered"
        print(paste0(Npre-Npost, " non-zero hic_enh_total elements dropped with zero (", zeros_print, ") hic_contact"))

        # compute scores
        print('    Normalizing HiChIP components...')
        ef <- normalize_hichip(ef, decomp_scores=decomp_scores)
        if (decomp_scores) {
            print('    Computing hic.Score ...')
            ef <- compute_score(ef, prefix='hic')
        }

        # merge activities and contacts for ABC.Score calculation
        f <- merge(af, ef)

        print("    Computing activity.Score ...")
        f <- compute_score(f, prefix='activity')

        outprefix <- paste0(sn, '.meanQN')
        f <- compute_score(f,
                           activity_col='activity_base',
                           contact_col='hic_contact_pl_scaled_adj',
                           prefix='ABC') %>%
            dplyr::select(-CellType) %>%
            mutate(CellType = outprefix)


        # output
        if (is.null(filt_zeros)) filt_zeros <- "no"
        if (decomp_scores) outprefix <- paste0(outprefix, '.decomp.', filt_zeros, 'ZerosFilt')
        outname <- file.path(outdir, paste0(outprefix, '.EnhancerPredictionsAllPutative.txt.gz'))
        print(paste0('    Writing ',outname))
        # append in case non-expressed genes included (2 files per sample)
        if (file.exists(outname)) {
            write_tsv(f, outname, append=TRUE)
        } else {
            write_tsv(f, outname, append=FALSE)
        }

        rm(f)

    }

}


parser <- ArgumentParser(description='Quantile normalize ABC components to the mean distribution of all samples and filter elements with minimum counts.')

parser$add_argument('--filt_zeros',
                    type='character',
                    default=NULL, # /home/kpettie/code/github/plotting
                    help="'any' for filtering out post-QN elements == 0 in any sample, 'all' for for filtering out post-QN elements == 0 in all samples")
parser$add_argument('--decomp_scores',
                    action='store_true',
                    default=FALSE, # /home/kpettie/code/github/plotting
                    help="Whether to decompose score into separate scores for H3K27ac, HiC, and ATAC. Uses VCsqrt to estimate H3K27ac and HiC from HiChIP data.")
parser$add_argument('--plotdir',
                    type='character',
                    default=NULL, # /home/kpettie/code/github/plotting
                    help="Directory with plotting function in 'plotting.R'. Required to make plots")
parser$add_argument('--include_nonexpressed',
                    action='store_true',
                    default=FALSE,
                    help="Inlude non-expressed genes (in cell-type provided to upstream ABC processing) in quantile normalization for downstream analysis (e.g., overlap with data from other cell types)")
parser$add_argument('--pred_suffix',
                    type='character',
                    default='HiC_no_QN',
                    help="Suffix of sample name indicating type of previous normalization.")
parser$add_argument('--pred_dir',
                    type='character',
                    default='.',
                    help="Directory with enhancer predictions from ABC pipeline")
parser$add_argument('-o', '--outdir',
                    type='character',
                    default='.')

opt <- parser$parse_args()

filt_zeros <- opt$filt_zeros
decomp_scores <- opt$decomp_scores
plotdir <- opt$plotdir
incl_nonexpr <- opt$include_nonexpressed
pred_dir <- opt$pred_dir
pred_suff <- opt$pred_suffix
outdir <- opt$outdir

if (incl_nonexpr) {
  filepatt <- '.*\\.EnhancerPredictionsAllPutative.*\\.txt\\.gz'
} else {
  filepatt <- '.*\\.EnhancerPredictionsAllPutative\\.txt\\.gz'
}

predfnames <- list.files(pred_dir,
                         pattern=paste0('[A-Z]{3}_rep[1-2]\\.',pred_suff,filepatt),
                         recursive=TRUE,
                         full.names=TRUE)

adfcdf <- mergeActivitiesContacts(predfnames, min_hic=0, bin_totals=decomp_scores, merge_nonexpr=incl_nonexpr, debug=FALSE)
adf <- adfcdf[[1]]
cdf <- adfcdf[[2]]

# keep components separate until after score computation
adfqn <- qnorm_separate_promoters(adf %>% dplyr::select(-starts_with('hic_enh_total')),
                                  colprefix='activity_base',
                                  filt_zeros=filt_zeros)
edfqn <- qnorm_separate_promoters(adf %>% dplyr::select(-starts_with('activity_base')),
                                  colprefix='hic_enh_total',
                                  filt_zeros=filt_zeros)
cdfqn <- qnorm_separate_promoters(cdf, colprefix='hic_contact', filt_zeros=filt_zeros)

makeQNpredictions(predfnames, adfqn, edfqn, cdfqn, outdir=outdir, decomp_scores=decomp_scores, filt_zeros=filt_zeros)

if (!is.null(plotdir)) {

    source(file.path(plotdir, 'plotting.R'))

    # plotting stuff here
    popco <- popPlotColors(pops=c("CEU", "FIN", "IBS", "TSI", "ESN", "GWD", "LWK", "YRI"))

    p1 <- groupedBoxplot(plotPrepFromMerge(adf, colprefix='activity_base', filt_zeros=TRUE),
                          'sample',
                          'activity_base',
                          groupvar='class',
                          xlab='Sample',
                          ylab='Non-zero ATAC RPM',
                          logscale=TRUE,
                          colorX=TRUE,
                          colorvals=popco %>% pull(hex),
                          showleg=FALSE,
                          legendpos='right',
                          w=7,h=7)
    ggsave(file.path(outdir, 'ATAC_RPM.boxplot.png'), width=7, height=7)

    p2 <- groupedBoxplot(plotPrepFromMerge(adfqn, colprefix='activity_base', filt_zeros=TRUE),
                         'sample',
                         'activity_base',
                         groupvar='class',
                         xlab='Sample',
                         ylab='Non-zero QN ATAC RPM',
                         logscale=TRUE,
                         colorX=TRUE,
                         colorvals=popco %>% pull(hex),
                         showleg=FALSE,
                         legendpos='right',
                         w=7,h=7)
    ggsave(file.path(outdir, 'ATAC_RPM_QN.boxplot.png'), width=7, height=7)

    ## filtering out zeros is essential for pivot_longer not to require >150GB
    ## memory in plotPrepFromMerge for hic_contact data

    p3 <- groupedBoxplot(plotPrepFromMerge(cdf, colprefix='hic_contact', filt_zeros=TRUE),
                         'sample',
                         'hic_contact',
                         groupvar='class',
                         xlab='Sample',
                         ylab='Non-zero raw HiC contact',
                         logscale=TRUE,
                         colorX=TRUE,
                         colorvals=popco %>% pull(hex),
                         showleg=FALSE,
                         legendpos='right',
                         w=7,h=7)
    ggsave(file.path(outdir, 'HiC_contact_raw.boxplot.png'), width=7, height=7)

    p4 <- groupedBoxplot(plotPrepFromMerge(cdfqn, colprefix='hic_contact', filt_zeros=TRUE) %>%
                            dplyr::filter(hic_contact > 0),
                         'sample',
                         'hic_contact',
                         groupvar='class',
                         xlab='Sample',
                         ylab='Non-zero QN HiC contact',
                         logscale=TRUE,
                         colorX=TRUE,
                         colorvals=popco %>% pull(hex),
                         showleg=FALSE,
                         legendpos='right',
                         w=7,h=7)
    ggsave(file.path(outdir, 'HiC_contact_QN.boxplot.png'), width=7, height=7)

}
